#include <chrono>
#include <cstddef>
#include <iostream>
#include <thread>
#include <vector>

int counter = 0;

void increment_counter() {
    // Sleep to give the main loop time to spawn some threads.
    std::this_thread::sleep_for(std::chrono::milliseconds(15));
    // Is this thread safe?
    ++counter;
}

int main() {
    // We're going to create 500 threads...
    const std::size_t num_threads = 500;

    {
        // Each thread will execute the function increment_counter.
        std::vector<std::jthread> threads;
        threads.reserve(num_threads);
        for (std::size_t i = 0; i < num_threads; i++) {
            threads.emplace_back(std::jthread(increment_counter));
        }
    }

    // What will the value of counter be when this code finishes running?
    std::cout << "counter: " << counter << std::endl;
}

/*
 *                                !!! ANSWER BELOW !!!
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 * It's important to understand that while the operation ++counter looks like
 * "one step", it's actually three CPU instructions.
 *
 * 	1. load the value from memory into a CPU register.
 * 	2. increment the value.
 * 	3. store the result in memory.
 *
 * The assembly might looks like this:
 *
 * 	load	reg0, [counter]
 * 	inc	reg0, 1
 * 	store	reg0, [counter]
 *
 * Becasue a single operation in C++ is actually three assembly instructions,
 * it's possible that multiple threads running in parallel can be performing
 * these operations at the same time but be at different steps.
 *
 * Below is the assembly generated by GCC:
 *
 * 	Thread A		Thread B
 *      -------------------------------------------
 * 	mov eax, counter[rip]
 * 	add eax, 1		mov eax, counter[rip]
 * 	mov counter[rip], eax	add eax, 1
 * 	                        mov counter[rip], eax
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *                 DO YOU KNOW HOW TO SOLVE THIS PROBLEM WITHOUT LOCKS?
 *
 *
 * 
 *
 *
 * 
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 * Intel Intrinsics Guide:
 *
 * 	https://www.intel.com/
 *	content/www/us/en/docs/intrinsics-guide/index.html
 *
 * Synopsis
 *
 *	void _aadd_i64 (__int64* __A, __int64 __B)
 *
 * Instruction
 *
 * 	aadd m64, r64
 *
 * Description
 *
 *	Atomically add a 64-bit value at memory operand __A and a 64-bit __B,
 *	and store the result to the same memory location.
 *
 * Operation MEM[__A+63:__A] :=
 *	MEM[__A+63:__A] + __B[63:0]
 *
 */
